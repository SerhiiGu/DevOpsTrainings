# Cache zone config
#fastcgi_cache_path /var/cache/nginx levels=2:2 keys_zone=MY_CACHE:20m inactive=60m max_size=1g;
#fastcgi_cache_key "$scheme$request_method$host$request_uri|$request_body"; # Add $request_body to the key!

# Vocabulary for LUA index - in the http section
#lua_shared_dict cache_index 20m;

# Store thec calculation of the cache HIT/MISS/EXPIRED/BYPASS queries
#lua_shared_dict cache_stats 10m;


    log_format  mobileapi '$remote_addr - $remote_user [$time_local] "$request" '
                          '$status $body_bytes_sent "$http_referer" '
                          '"$http_user_agent" "$http_x_forwarded_for" '
                          '"$lua_cache_status" "$mobile_app_response_code"';

server {
    listen 94;
    server_name localhost;
    root /var/www/html;
    index mobile-api_94.php;
    access_log /var/log/nginx/access.log mobileapi;

    # Entrypont for ALL
    location / {
        recursive_error_pages on;

        # Different TTL for /lang_list can be implemented only on a different location
        if ($uri = "/lang-list") {
            error_page 419 = @logic_ttl30;
            return 419;
        }

        error_page 418 = @logic;
        return 418;
    }

    # Main cache logic
    location @logic {
        internal;
        lua_need_request_body on;

        set $lua_cache_status "-";
	set $mobile_app_response_code 999;
        set $my_cache_key "";
        set $skip_cache 0;
        set $full_key "";

        # The list of allowed URI in this file
        rewrite_by_lua_file /etc/nginx/lua/mobile_rewrite_logic_94.lua;

        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root/mobile-api_94.php;
        fastcgi_pass php:9000;

        # Use our generated Lua key
        fastcgi_cache MY_CACHE;
        fastcgi_cache_key $full_key;

        log_by_lua_file /etc/nginx/lua/mobile_log_94.lua;

        # Cache skip conditions
        fastcgi_cache_bypass $skip_cache;
        fastcgi_no_cache $skip_cache;

        header_filter_by_lua_file /etc/nginx/lua/mobile_header_filter_94.lua;

        # add_header X-Cache-Status $upstream_cache_status;
        add_header X-Debug-Key $my_cache_key;  # Temp, for debug

        # Use cache when page updating or we get problems with backend
        fastcgi_cache_use_stale updating error timeout http_500 http_503;

        # Use background cache renewal: user got file from cache, but Nginx update the cacheed page in background
        fastcgi_cache_background_update on;

        # Important: Only one request will pass to backend for the cache renewal
        fastcgi_cache_lock on;
        fastcgi_cache_lock_timeout 5s;

        fastcgi_cache_methods POST; # Enable POST cache
        fastcgi_cache_valid 200 5m;
    }


    # Special location for /lang_list with 30m TTL
    location @logic_ttl30 {
        internal;
        lua_need_request_body on;
        set $mobile_app_response_code 999;
        set $lua_cache_status "-";
        set $my_cache_key "";
        set $skip_cache 0;
        set $full_key "";

        rewrite_by_lua_file /etc/nginx/lua/mobile_rewrite_logic_94.lua;

        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root/mobile-api_94.php;
        fastcgi_pass php:9000;

        fastcgi_cache MY_CACHE;
        fastcgi_cache_key $full_key;

        log_by_lua_file /etc/nginx/lua/mobile_log_94.lua;

        fastcgi_cache_bypass $skip_cache;
        fastcgi_no_cache $skip_cache;

        header_filter_by_lua_file /etc/nginx/lua/mobile_header_filter_94.lua;

        # add_header X-Cache-Status $upstream_cache_status;
        add_header X-Debug-Key $my_cache_key;  # Temp, for debug

        fastcgi_cache_use_stale updating error timeout http_500 http_503;
        fastcgi_cache_background_update on;
        fastcgi_cache_lock on;
        fastcgi_cache_lock_timeout 5s;

        fastcgi_cache_methods POST;
        fastcgi_cache_valid 200 30m;
    }


    # slow variant, generates high I/O (with grep)
    location = /purge_cache {
        allow 127.0.0.1;  # Set restrictions!
        allow 172.16.0.0/12; # Docker network
	allow 192.168.1.0/24;
        deny all;

        lua_need_request_body on;
        content_by_lua_file /etc/nginx/lua/purge_cache_grep.lua;
    }


    # Fast way to purge URI, but LUA table stores only in RAM, and after restart nginx(not reload) it may not found files even if they will be at the FS
    location = /purge_cache_lua_table {
        allow 127.0.0.1;  # Set restrictions!
        allow 172.16.0.0/12; # Docker network
        deny all;

        lua_need_request_body on;
        content_by_lua_file /etc/nginx/lua/purge_cache_lua_table.lua;
    }



    # Get detailed HIT/MISS+EXPIRED/BYPASS stats for every location
    location = /cache_show_stats {
        allow 127.0.0.1;
        allow 172.16.0.0/12;  # Docker network
        allow 192.168.1.0/24; # Local network
        deny all;

        default_type application/json;
        content_by_lua_file /etc/nginx/lua/cache_show_stats.lua;
    }


    # Get total, global cache stats
    location = /cache_summary {
        allow 127.0.0.1;
        allow 172.16.0.0/12;
        allow 192.168.1.0/24;
        deny all;

        default_type text/plain;
        content_by_lua_file /etc/nginx/lua/cache_summary.lua;
    }


    # Get total number of the cache keys in the LUA table
    location = /debug_cache_total {
        allow 127.0.0.1;
        allow 172.16.0.0/12;
        allow 192.168.1.0/24;
        deny all;

        default_type application/json;
        content_by_lua_file /etc/nginx/lua/debug_cache_total.lua;
    }


    # Get 1000 records from the LUA table
    location = /debug_cache_list {
        allow 127.0.0.1;
        allow 172.16.0.0/12;
        allow 192.168.1.0/24;
        deny all;

        default_type application/json;
        content_by_lua_file /etc/nginx/lua/debug_cache_list.lua;
    }


    # Disable direct access to .php scripts
    location ~ \.php$ {
        return 404;
    }
}


