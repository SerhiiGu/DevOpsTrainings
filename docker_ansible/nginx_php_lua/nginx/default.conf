# Налаштування зони кешу
fastcgi_cache_path /var/cache/nginx levels=1:2 keys_zone=MY_CACHE:10m inactive=60m max_size=1g;
fastcgi_cache_key "$scheme$request_method$host$request_uri|$request_body"; # Додаємо $request_body до ключа!

server {
    listen 90;
    server_name localhost;
    root /var/www/html;
    index index.php index.html;

location /lua_post_test {
    content_by_lua_block {
        -- 1. Читаємо тіло запиту (обов'язково!)
        ngx.req.read_body()

        -- 2. Отримуємо всі POST параметри в таблицю
        local args, err = ngx.req.get_post_args()

        if not args then
            ngx.say("Не вдалося отримати POST дані: ", err)
            return
        end

        ngx.say("--- Lua отримала такі параметри ---")

        -- 3. Проходимо циклом по всіх параметрах
        for key, val in pairs(args) do
            if type(val) == "table" then
                -- Якщо параметр передано декілька разів (наприклад, array[])
                ngx.say(key, ": ", table.concat(val, ", "))
            else
                ngx.say(key, ": ", val)
            end
        end
    }
}




location /lua_to_php {
    # 1. Lua обробка
    access_by_lua_block {
        ngx.req.read_body()
        local args = ngx.req.get_post_args()
        if args["user"] == "banned" then
            ngx.exit(ngx.HTTP_FORBIDDEN)
        end
        if args["user"] then
            ngx.req.set_header("X-Lua-User", args["user"])
        end
    }

    # 2. Налаштування кешу
    fastcgi_cache MY_CACHE;
    fastcgi_cache_methods POST; # ДОЗВОЛЯЄМО кешування POST-запитів
    fastcgi_cache_valid 200 10m;

    # Додаємо статус кешу для перевірки
    add_header X-Cache-Status $upstream_cache_status;

    # 3. Передача на PHP
    fastcgi_pass php:9000;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root/index.php;
}




location /lua_json_test {
    content_by_lua_block {
        local cjson = require("cjson")

        -- 1. Читаємо тіло запиту
        ngx.req.read_body()
        local body_data = ngx.req.get_body_data()

        if not body_data then
            -- Якщо тіло занадто велике, воно може бути у тимчасовому файлі
            local body_file = ngx.req.get_body_file()
            if body_file then
                local f = io.open(body_file, "r")
                body_data = f:read("*all")
                f:close()
            end
        end

        if not body_data then
            ngx.status = 400
            ngx.say("Помилка: Пусте тіло запиту")
            return
        end

        -- 2. Декодуємо JSON
        local status, data = pcall(cjson.decode, body_data)

        if not status then
            ngx.status = 400
            ngx.say("Помилка: Невалідний JSON")
            return
        end

        -- 3. Виводимо результат
        ngx.say("--- JSON розпарсено успішно ---")
        if data["user"] then
            ngx.say("Користувач: ", data["user"])
        end
        if data["email"] then
            ngx.say("Email: ", data["email"])
        end

        -- Можна вивести весь об'єкт для перевірки
        ngx.say("Весь JSON: ", body_data)
    }
}




location /process_json {
    # Щоб $request_body був доступний для ключа кешу, Nginx повинен його прочитати
    client_body_buffer_size 128k;

    access_by_lua_block {
        local cjson = require("cjson")

        -- Читаємо тіло
        ngx.req.read_body()
        local body_data = ngx.req.get_body_data()

        if body_data then
            -- Декодуємо JSON (використовуємо pcall для безпеки)
            local status, data = pcall(cjson.decode, body_data)

            if status and data["user"] then
                -- Додаємо кастомний заголовок для PHP
                ngx.req.set_header("X-Lua-User", data["user"])
                -- Можна також додати заголовок з часом обробки
                ngx.req.set_header("X-Lua-Timestamp", ngx.now())
            end
        end
    }

    # Налаштування кешування для JSON POST
    fastcgi_cache MY_CACHE;
    fastcgi_cache_methods POST;

    # Ключ кешу вже містить $request_body (див. пункт 1),
    # тому різні JSON тіла створять різні файли кешу
    fastcgi_cache_valid 200 5m;

    add_header X-Cache-Status $upstream_cache_status;

    fastcgi_pass php:9000;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root/index.php;
}




location /process_json_2 {
    # 1. Ініціалізуємо змінні (важливо: до Lua блоку)
    set $skip_cache 0;
    set $lua_user "guest";

    # 2. Читання тіла запиту для роботи $request_body у кеш-ключі
    client_body_buffer_size 128k;

    # 3. Логіка Lua
    access_by_lua_block {
        local cjson = require("cjson")
        ngx.req.read_body()
        local body = ngx.req.get_body_data()

        if body then
            local status, data = pcall(cjson.decode, body)
            if status then
                -- Динамічне вимкнення кешу через JSON поле
                if data["nocache"] == true or data["nocache"] == "1" then
                    ngx.var.skip_cache = 1
                end

                -- Логіка: не кешувати запити від конкретного юзера (наприклад, admin)
                if data["user"] == "admin" then
                    ngx.var.skip_cache = 1
                end

                -- Передаємо ім'я юзера в заголовок для PHP
                if data["user"] then
                    ngx.req.set_header("X-Lua-User", data["user"])
                end
            end
        end
    }

    # 4. Налаштування FastCGI Cache
    fastcgi_cache MY_CACHE;
    fastcgi_cache_methods POST;

    # Вирішальні директиви для динаміки:
    fastcgi_cache_bypass $skip_cache;  # Якщо 1 — не беремо дані з кешу (йдемо до PHP)
    fastcgi_no_cache $skip_cache;      # Якщо 1 — не зберігаємо відповідь у кеш

    fastcgi_cache_valid 200 10m;

    # Ігноруємо стандартні заборони кешування від PHP, якщо хочемо жорстко кешувати
    fastcgi_ignore_headers Cache-Control Expires Set-Cookie;

    # 5. Передача на PHP-FPM
    fastcgi_pass php:9000;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root/index.php;

    # 6. Відладочні заголовки
    add_header X-Cache-Status $upstream_cache_status; # HIT, MISS, BYPASS
    add_header X-Lua-Skip-Used $skip_cache;          # Чи спрацював скіп
}




    location /lua_ver {
        default_type 'text/plain';
        content_by_lua_block {
            ngx.say("Lua module is active!")
            ngx.say("Nginx version: " .. ngx.var.nginx_version)
        }
    }

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        fastcgi_pass php:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
}


