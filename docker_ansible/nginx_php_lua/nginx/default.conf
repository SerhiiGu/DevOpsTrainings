# Cache zone config
fastcgi_cache_path /var/cache/nginx levels=1:2 keys_zone=MY_CACHE:10m inactive=60m max_size=1g;
fastcgi_cache_key "$scheme$request_method$host$request_uri|$request_body"; # Додаємо $request_body до ключа!

server {
    listen 90;
    server_name localhost;
    root /var/www/html;
    index index.php index.html;

location /lua_post_test {
    content_by_lua_block {
        -- Get the request body
        ngx.req.read_body()

        -- Get all POST parameters
        local args, err = ngx.req.get_post_args()

        if not args then
            ngx.say("Can't get POST data: ", err)
            return
        end

        ngx.say("--- Lua got parameters ---")

        -- Print catched data
        for key, val in pairs(args) do
            if type(val) == "table" then
                ngx.say(key, ": ", table.concat(val, ", "))
            else
                ngx.say(key, ": ", val)
            end
        end
    }
}




location /lua_to_php {
    # Lua processing
    access_by_lua_block {
        ngx.req.read_body()
        local args = ngx.req.get_post_args()
        if args["user"] == "banned" then
            ngx.exit(ngx.HTTP_FORBIDDEN)
        end
        if args["user"] then
            ngx.req.set_header("X-Lua-User", args["user"])
        end
    }

    # Cache config
    fastcgi_cache MY_CACHE;
    fastcgi_cache_methods POST; # we need to cachee POST queries (default - disabled)
    fastcgi_cache_valid 200 10m;

    # Add cache state for checking
    add_header X-Cache-Status $upstream_cache_status;

    # PHP-backend
    fastcgi_pass php:9000;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root/index.php;
}




location /lua_json_test {
    content_by_lua_block {
        local cjson = require("cjson")

        -- Get the request body
        ngx.req.read_body()
        local body_data = ngx.req.get_body_data()

        if not body_data then
            -- Too big request body may be in the temp file 
            local body_file = ngx.req.get_body_file()
            if body_file then
                local f = io.open(body_file, "r")
                body_data = f:read("*all")
                f:close()
            end
        end

        if not body_data then
            ngx.status = 400
            ngx.say("Error: Empty request body")
            return
        end

        -- JSON decoding
        local status, data = pcall(cjson.decode, body_data)

        if not status then
            ngx.status = 400
            ngx.say("Error: Invalid JSON")
            return
        end

        -- Print the result
        ngx.say("--- JSON parsed successfully ---")
        if data["user"] then
            ngx.say("User: ", data["user"])
        end
        if data["email"] then
            ngx.say("Email: ", data["email"])
        end

        ngx.say("All JSON: ", body_data)
    }
}




location /process_json {
    # Get $request_body for enabling it as a cache key
    client_body_buffer_size 128k;

    access_by_lua_block {
        local cjson = require("cjson")

        -- Get request body
        ngx.req.read_body()
        local body_data = ngx.req.get_body_data()

        if body_data then
            -- Decode JSON (use pcall for safety)
            local status, data = pcall(cjson.decode, body_data)

            if status and data["user"] then
                -- Add custom PHP headers
                ngx.req.set_header("X-Lua-User", data["user"])
                ngx.req.set_header("X-Lua-Timestamp", ngx.now())
            end
        end
    }

    # Config cache for JSON POST
    fastcgi_cache MY_CACHE;
    fastcgi_cache_methods POST;

    fastcgi_cache_valid 200 5m;

    add_header X-Cache-Status $upstream_cache_status;

    fastcgi_pass php:9000;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root/index.php;
}




location /process_json_2 {
    # Init variables BEFORE Lua
    set $skip_cache 0;
    set $lua_user "guest";

    # Get $request_body
    client_body_buffer_size 128k;

    # LUA itself
    access_by_lua_block {
        local cjson = require("cjson")
        ngx.req.read_body()
        local body = ngx.req.get_body_data()

        if body then
            local status, data = pcall(cjson.decode, body)
            if status then
                -- Dynamic cache on/off through JSON field
                if data["nocache"] == true or data["nocache"] == "1" then
                    ngx.var.skip_cache = 1
                end

                -- Additional: skip cache for user admin
                if data["user"] == "admin" then
                    ngx.var.skip_cache = 1
                end

                -- Add username as PHP header
                if data["user"] then
                    ngx.req.set_header("X-Lua-User", data["user"])
                end
            end
        end
    }

    # FastCGI Cache
    fastcgi_cache MY_CACHE;
    fastcgi_cache_methods POST;

    fastcgi_cache_bypass $skip_cache;  # 1 — dont use cache for answer(go to backend)
    fastcgi_no_cache $skip_cache;      # 1 — dont store sequest in the cache

    fastcgi_cache_valid 200 10m;

    # ignore cache headers from backend (optional)
    fastcgi_ignore_headers Cache-Control Expires Set-Cookie;

    fastcgi_pass php:9000;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root/index.php;

    # Extra headers to see how cache works
    add_header X-Cache-Status $upstream_cache_status; # HIT, MISS, BYPASS
    add_header X-Lua-Skip-Used $skip_cache;          # Are cache was skipped?
}




location ^~ /cache_only_allowed_fields_json {
    set $my_cache_key "";
    set $skip_cache 0;

    # 1. Read the body and parse it
    lua_need_request_body on;

    access_by_lua_block {
        local cjson = require "cjson"
        local body = ngx.var.request_body

        if not body or body == "" then -- empty body => skip cache
            ngx.var.skip_cache = 1
            return
        end

        local status, data = pcall(cjson.decode, body)
        if not status or type(data) ~= "table" then
            ngx.var.skip_cache = 1 -- Invalid JSON => skip cache
            return
        end

        -- Allowed fields list
        local allowed_keys = { page = true, valid = true }
        local sorted_keys = {}

	for k, v in pairs(data) do
            if not allowed_keys[k] then
                ngx.var.skip_cache = 1 -- If we found filed not from allowed_keys => skip cache completely
                return
            end
            table.insert(sorted_keys, k)
        end

        -- Format a stable key (sort the fields so that the key does not depend on the order in JSON)
        table.sort(sorted_keys)
        local key_parts = {}
        for _, k in ipairs(sorted_keys) do
            table.insert(key_parts, k .. "=" .. tostring(data[k]))
        end

        ngx.var.my_cache_key = table.concat(key_parts, ":") -- format the final cache key for serving cache
    }

    # 2. Cache config
    # Set the prorer config options for backend
    include fastcgi_params;
    set $my_file "index.php";
    if ($request_uri ~* ^/cache_only_allowed_fields_json/([^?]+)) {
        set $my_file $1;
    }
    fastcgi_param SCRIPT_FILENAME $document_root/$my_file;
    fastcgi_pass php:9000;

    # Use our generated Lua key
    fastcgi_cache MY_CACHE;
    fastcgi_cache_key "$scheme$request_method$host$request_uri|$my_cache_key";

    # Cache skip conditions
    fastcgi_cache_bypass $skip_cache;
    fastcgi_no_cache $skip_cache;

    add_header X-Cache-Status $upstream_cache_status;
    add_header X-Debug-Key $my_cache_key;  # Temp for debug

    fastcgi_cache_methods POST; # Enable POST cache
    fastcgi_cache_valid 200 5m;
}



    location /lua_ver {
        default_type 'text/plain';
        content_by_lua_block {
            ngx.say("Lua module is active!")
            ngx.say("Nginx version: " .. ngx.var.nginx_version)
        }
    }

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        fastcgi_pass php:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }

}


