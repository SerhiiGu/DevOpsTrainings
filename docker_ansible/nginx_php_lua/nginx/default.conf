# Cache zone config
fastcgi_cache_path /var/cache/nginx levels=2:2 keys_zone=MY_CACHE:20m inactive=60m max_size=1g;
fastcgi_cache_key "$scheme$request_method$host$request_uri|$request_body"; # Додаємо $request_body до ключа!

# Vocabulary for LUA index - in the http section
lua_shared_dict cache_index 20m;

server {
    listen 90;
    server_name localhost;
    root /var/www/html;
    index index.php index.html;

location /lua_post_test {
    content_by_lua_block {
        -- Get the request body
        ngx.req.read_body()

        -- Get all POST parameters
        local args, err = ngx.req.get_post_args()

        if not args then
            ngx.say("Can't get POST data: ", err)
            return
        end

        ngx.say("--- Lua got parameters ---")

        -- Print catched data
        for key, val in pairs(args) do
            if type(val) == "table" then
                ngx.say(key, ": ", table.concat(val, ", "))
            else
                ngx.say(key, ": ", val)
            end
        end
    }
}




location /lua_to_php {
    # Lua processing
    access_by_lua_block {
        ngx.req.read_body()
        local args = ngx.req.get_post_args()
        if args["user"] == "banned" then
            ngx.exit(ngx.HTTP_FORBIDDEN)
        end
        if args["user"] then
            ngx.req.set_header("X-Lua-User", args["user"])
        end
    }

    # Cache config
    fastcgi_cache MY_CACHE;
    fastcgi_cache_methods POST; # we need to cachee POST queries (default - disabled)
    fastcgi_cache_valid 200 10m;

    # Add cache state for checking
    add_header X-Cache-Status $upstream_cache_status;

    # PHP-backend
    fastcgi_pass php:9000;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root/index.php;
}




location /lua_json_test {
    content_by_lua_block {
        local cjson = require("cjson")

        -- Get the request body
        ngx.req.read_body()
        local body_data = ngx.req.get_body_data()

        if not body_data then
            -- Too big request body may be in the temp file 
            local body_file = ngx.req.get_body_file()
            if body_file then
                local f = io.open(body_file, "r")
                body_data = f:read("*all")
                f:close()
            end
        end

        if not body_data then
            ngx.status = 400
            ngx.say("Error: Empty request body")
            return
        end

        -- JSON decoding
        local status, data = pcall(cjson.decode, body_data)

        if not status then
            ngx.status = 400
            ngx.say("Error: Invalid JSON")
            return
        end

        -- Print the result
        ngx.say("--- JSON parsed successfully ---")
        if data["user"] then
            ngx.say("User: ", data["user"])
        end
        if data["email"] then
            ngx.say("Email: ", data["email"])
        end

        ngx.say("All JSON: ", body_data)
    }
}




location /process_json {
    # Get $request_body for enabling it as a cache key
    client_body_buffer_size 128k;

    access_by_lua_block {
        local cjson = require("cjson")

        -- Get request body
        ngx.req.read_body()
        local body_data = ngx.req.get_body_data()

        if body_data then
            -- Decode JSON (use pcall for safety)
            local status, data = pcall(cjson.decode, body_data)

            if status and data["user"] then
                -- Add custom PHP headers
                ngx.req.set_header("X-Lua-User", data["user"])
                ngx.req.set_header("X-Lua-Timestamp", ngx.now())
            end
        end
    }

    # Config cache for JSON POST
    fastcgi_cache MY_CACHE;
    fastcgi_cache_methods POST;

    fastcgi_cache_valid 200 5m;

    add_header X-Cache-Status $upstream_cache_status;

    fastcgi_pass php:9000;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root/index.php;
}




location /process_json_2 {
    # Init variables BEFORE Lua
    set $skip_cache 0;
    set $lua_user "guest";

    # Get $request_body
    client_body_buffer_size 128k;

    # LUA itself
    access_by_lua_block {
        local cjson = require("cjson")
        ngx.req.read_body()
        local body = ngx.req.get_body_data()

        if body then
            local status, data = pcall(cjson.decode, body)
            if status then
                -- Dynamic cache on/off through JSON field
                if data["nocache"] == true or data["nocache"] == "1" then
                    ngx.var.skip_cache = 1
                end

                -- Additional: skip cache for user admin
                if data["user"] == "admin" then
                    ngx.var.skip_cache = 1
                end

                -- Add username as PHP header
                if data["user"] then
                    ngx.req.set_header("X-Lua-User", data["user"])
                end
            end
        end
    }

    # FastCGI Cache
    fastcgi_cache MY_CACHE;
    fastcgi_cache_methods POST;

    fastcgi_cache_bypass $skip_cache;  # 1 — dont use cache for answer(go to backend)
    fastcgi_no_cache $skip_cache;      # 1 — dont store sequest in the cache

    fastcgi_cache_valid 200 10m;

    # ignore cache headers from backend (optional)
    fastcgi_ignore_headers Cache-Control Expires Set-Cookie;

    fastcgi_pass php:9000;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root/index.php;

    # Extra headers to see how cache works
    add_header X-Cache-Status $upstream_cache_status; # HIT, MISS, BYPASS
    add_header X-Lua-Skip-Used $skip_cache;          # Are cache was skipped?
}




location ^~ /cache_only_allowed_fields_json {
    set $my_cache_key "";
    set $skip_cache 0;

    # 1. Read the body and parse it
    lua_need_request_body on;

    access_by_lua_block {
        local cjson = require "cjson"
        local body = ngx.var.request_body

        if not body or body == "" then -- empty body => skip cache
            ngx.var.skip_cache = 1
            return
        end

        local status, data = pcall(cjson.decode, body)
        if not status or type(data) ~= "table" then
            ngx.var.skip_cache = 1 -- Invalid JSON => skip cache
            return
        end

        -- Allowed fields list
        local allowed_keys = { page = true, valid = true }
        local sorted_keys = {}

	for k, v in pairs(data) do
            if not allowed_keys[k] then
                ngx.var.skip_cache = 1 -- If we found filed not from allowed_keys => skip cache completely
                return
            end
            table.insert(sorted_keys, k)
        end

        -- Format a stable key (sort the fields so that the key does not depend on the order in JSON)
        table.sort(sorted_keys)
        local key_parts = {}
        for _, k in ipairs(sorted_keys) do
            table.insert(key_parts, k .. "=" .. tostring(data[k]))
        end

        ngx.var.my_cache_key = table.concat(key_parts, ":") -- format the final cache key for serving cache
    }

    # 2. Cache config
    # Set the prorer config options for backend
    include fastcgi_params;
    set $my_file "index.php";
    if ($request_uri ~* ^/cache_only_allowed_fields_json/([^?]+)) {
        set $my_file $1;
    }
    fastcgi_param SCRIPT_FILENAME $document_root/$my_file;
    fastcgi_pass php:9000;

    # Use our generated Lua key
    fastcgi_cache MY_CACHE;

    # FastCGI Key and log_by_lua_block block for /purge_cache_fast
    set $full_key "$scheme$request_method$host$request_uri|$my_cache_key";
    fastcgi_cache_key $full_key;

    # Block for /purge_cache_fast
    log_by_lua_block {
        local cache_index = ngx.shared.cache_index
        local key = ngx.var.full_key
        local uri = ngx.var.uri

        -- Calculate cache like Nginx (levels=2:2)
        local hash = ngx.md5(key)
        local path = "/var/cache/nginx/" .. string.sub(hash, -2) .. "/" .. string.sub(hash, -4, -3) .. "/" .. hash

	-- Undate cache LUA table (works with HIT and MISS)
        local existing = cache_index:get(uri) or ""
        if not string.find(existing, path, 1, true) then
            local new_val = (existing == "" and path or existing .. "," .. path)
            cache_index:set(uri, new_val)
        end
    }


    # Cache skip conditions
    fastcgi_cache_bypass $skip_cache;
    fastcgi_no_cache $skip_cache;

    add_header X-Cache-Status $upstream_cache_status;
    add_header X-Debug-Key $my_cache_key;  # Temp for debug

    fastcgi_cache_methods POST; # Enable POST cache
    fastcgi_cache_valid 200 5m;
}




# slow variant, generates high I/O
location /purge_cache {
    allow 127.0.0.1;  # Set restrictions!
    #allow 172.16.0.0/12; # Docker network
    deny all;

    lua_need_request_body on;

    content_by_lua_block {
        local cjson = require "cjson"
        local body = ngx.var.request_body
        local data = cjson.decode(body)

        if not data or not data.pages or type(data.pages) ~= "table" then
            ngx.status = 400
            ngx.say("Invalid JSON. Expected {'pages': ['/uri1', '/uri2']}")
            return
        end

        local cache_path = "/var/cache/nginx"
        local total_deleted = 0

        for _, uri_pattern in ipairs(data.pages) do
            -- Escaping URIs for security in the shell
            local safe_uri = uri_pattern:gsub("'", "'\\''")

	    -- COMMAND: grep -rl - find files => tee - list for the files counting => xargs rm -f - remove these files
            local cmd = string.format("grep -rl '%s' %s | tee /tmp/purged_list | wc -l && xargs rm -f < /tmp/purged_list", safe_uri, cache_path)

            local handle = io.popen(cmd)
            local result = handle:read("*a")
            handle:close()

            local count = tonumber(result) or 0
            total_deleted = total_deleted + count

	    ngx.log(ngx.ERR, "PURGE: Pattern: " .. uri_pattern .. " | Deleted: " .. count)
        end

        ngx.say("Purge command executed for " .. #data.pages .. " patterns." .. "Deleted " .. total_deleted .. " files")
    }
}




# Fast way to purge URI, but LUA table stores only in RAM, and after restart nginx(not reload) it may not found files even if they will be at the FS
location /purge_cache_lua_table {
    allow 127.0.0.1;
    deny all;

    lua_need_request_body on;

    content_by_lua_block {
        local cjson = require "cjson.safe"
        local cache_index = ngx.shared.cache_index
        local body = ngx.var.request_body

        if not body or body == "" then
            ngx.status = 400
            ngx.say("Error: Empty request body. Expected {'pages': ['/uri1', '/uri2']}")
            return
        end

	local data = cjson.decode(body)

        if not data or type(data.pages) ~= "table" then
            ngx.status = 400
            ngx.say("Error: Invalid format. Expected {'pages': ['/uri1', '/uri2']}")
            return
        end

        local deleted_total = 0
        for _, uri in ipairs(data.pages) do
            local paths_str = cache_index:get(uri)
            if paths_str then
                -- Get files path and remove files
                for path in string.gmatch(paths_str, '([^,]+)') do
                    if os.remove(path) then
                        deleted_total = deleted_total + 1
                    end
                end
                -- Clear index for this URI
                cache_index:delete(uri)
            end
        end
        ngx.say("Success: Purge finished. Deleted files: " .. deleted_total)
    }
}



# Get total number of the cache keys in the LUA table
# WARNING: If you have huge amount of rows, count may cause stuck Nginx process for a short time
location /debug_cache_total {
    allow 127.0.0.1;
    deny all;

    default_type application/json;

    content_by_lua_block {
        local cache_index = ngx.shared.cache_index
        -- Отримуємо всі ключі. 0 — без ліміту.
        local all_keys = cache_index:get_keys(0)

        local response = {
            total_count = #all_keys
        }

        local cjson = require "cjson"
        ngx.say(cjson.encode(response))
    }
}




# Get 1000 records from the LUA table
location /debug_cache_list {
    allow 127.0.0.1;
    deny all;

    default_type application/json;

    content_by_lua_block {
        local cjson = require "cjson"
        local cjson_safe = require "cjson.safe"
        local cache_index = ngx.shared.cache_index

        local limited_keys = cache_index:get_keys(1000)

        local index_data = {}
        for _, uri in ipairs(limited_keys) do
            local paths_str = cache_index:get(uri)
            local paths = {}
            if paths_str then
                for path in string.gmatch(paths_str, '([^,]+)') do
                    table.insert(paths, path)
                end
            end
            index_data[uri] = paths
        end

        local response = {
            showing_limit = 1000,
            index = index_data
        }
        cjson.encode_sparse_array(true)
	ngx.say(require("cjson").encode(response))
    }
}





    location /lua_ver {
        default_type 'text/plain';
        content_by_lua_block {
            ngx.say("Lua module is active!")
            ngx.say("Nginx version: " .. ngx.var.nginx_version)
        }
    }

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        fastcgi_pass php:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }

}


