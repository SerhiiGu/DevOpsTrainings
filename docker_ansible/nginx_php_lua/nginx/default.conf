# Cache zone config
fastcgi_cache_path /var/cache/nginx levels=2:2 keys_zone=MY_CACHE:20m inactive=60m max_size=1g;
fastcgi_cache_key "$scheme$request_method$host$request_uri|$request_body"; # Додаємо $request_body до ключа!

# Vocabulary for LUA index - in the http section
lua_shared_dict cache_index 20m;

server {
    listen 90;
    server_name localhost;
    root /var/www/html;
    index index.php index.html;

location /lua_post_test {
    content_by_lua_block {
        -- Get the request body
        ngx.req.read_body()

        -- Get all POST parameters
        local args, err = ngx.req.get_post_args()

        if not args then
            ngx.say("Can't get POST data: ", err)
            return
        end

        ngx.say("--- Lua got parameters ---")

        -- Print catched data
        for key, val in pairs(args) do
            if type(val) == "table" then
                ngx.say(key, ": ", table.concat(val, ", "))
            else
                ngx.say(key, ": ", val)
            end
        end
    }
}




location /lua_to_php {
    # Lua processing
    access_by_lua_block {
        ngx.req.read_body()
        local args = ngx.req.get_post_args()
        if args["user"] == "banned" then
            ngx.exit(ngx.HTTP_FORBIDDEN)
        end
        if args["user"] then
            ngx.req.set_header("X-Lua-User", args["user"])
        end
    }

    # Cache config
    fastcgi_cache MY_CACHE;
    fastcgi_cache_methods POST; # we need to cachee POST queries (default - disabled)
    fastcgi_cache_valid 200 10m;

    # Add cache state for checking
    add_header X-Cache-Status $upstream_cache_status;

    # PHP-backend
    fastcgi_pass php:9000;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root/index.php;
}




location /lua_json_test {
    content_by_lua_block {
        local cjson = require("cjson")

        -- Get the request body
        ngx.req.read_body()
        local body_data = ngx.req.get_body_data()

        if not body_data then
            -- Too big request body may be in the temp file 
            local body_file = ngx.req.get_body_file()
            if body_file then
                local f = io.open(body_file, "r")
                body_data = f:read("*all")
                f:close()
            end
        end

        if not body_data then
            ngx.status = 400
            ngx.say("Error: Empty request body")
            return
        end

        -- JSON decoding
        local status, data = pcall(cjson.decode, body_data)

        if not status then
            ngx.status = 400
            ngx.say("Error: Invalid JSON")
            return
        end

        -- Print the result
        ngx.say("--- JSON parsed successfully ---")
        if data["user"] then
            ngx.say("User: ", data["user"])
        end
        if data["email"] then
            ngx.say("Email: ", data["email"])
        end

        ngx.say("All JSON: ", body_data)
    }
}




location /process_json {
    # Get $request_body for enabling it as a cache key
    client_body_buffer_size 128k;

    access_by_lua_block {
        local cjson = require("cjson")

        -- Get request body
        ngx.req.read_body()
        local body_data = ngx.req.get_body_data()

        if body_data then
            -- Decode JSON (use pcall for safety)
            local status, data = pcall(cjson.decode, body_data)

            if status and data["user"] then
                -- Add custom PHP headers
                ngx.req.set_header("X-Lua-User", data["user"])
                ngx.req.set_header("X-Lua-Timestamp", ngx.now())
            end
        end
    }

    # Config cache for JSON POST
    fastcgi_cache MY_CACHE;
    fastcgi_cache_methods POST;

    fastcgi_cache_valid 200 5m;

    add_header X-Cache-Status $upstream_cache_status;

    fastcgi_pass php:9000;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root/index.php;
}




location /process_json_2 {
    # Init variables BEFORE Lua
    set $skip_cache 0;
    set $lua_user "guest";

    # Get $request_body
    client_body_buffer_size 128k;

    # LUA itself
    access_by_lua_block {
        local cjson = require("cjson")
        ngx.req.read_body()
        local body = ngx.req.get_body_data()

        if body then
            local status, data = pcall(cjson.decode, body)
            if status then
                -- Dynamic cache on/off through JSON field
                if data["nocache"] == true or data["nocache"] == "1" then
                    ngx.var.skip_cache = 1
                end

                -- Additional: skip cache for user admin
                if data["user"] == "admin" then
                    ngx.var.skip_cache = 1
                end

                -- Add username as PHP header
                if data["user"] then
                    ngx.req.set_header("X-Lua-User", data["user"])
                end
            end
        end
    }

    # FastCGI Cache
    fastcgi_cache MY_CACHE;
    fastcgi_cache_methods POST;

    fastcgi_cache_bypass $skip_cache;  # 1 — dont use cache for answer(go to backend)
    fastcgi_no_cache $skip_cache;      # 1 — dont store sequest in the cache

    fastcgi_cache_valid 200 10m;

    # ignore cache headers from backend (optional)
    fastcgi_ignore_headers Cache-Control Expires Set-Cookie;

    fastcgi_pass php:9000;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root/index.php;

    # Extra headers to see how cache works
    add_header X-Cache-Status $upstream_cache_status; # HIT, MISS, BYPASS
    add_header X-Lua-Skip-Used $skip_cache;          # Are cache was skipped?
}




location ^~ /cache_only_allowed_fields_json {
    lua_need_request_body on;

    set $my_cache_key "";
    set $skip_cache 0;

    rewrite_by_lua_block {
        local cjson = require "cjson"
        local body = ngx.req.get_body_data()

        if not body or body == "" then -- empty body => skip cache
            ngx.var.skip_cache = 1
            ngx.exec("@disk_cache")
            return
        end

        local status, data = pcall(cjson.decode, body)
        if not status or type(data) ~= "table" then
            ngx.var.skip_cache = 1 -- Invalid JSON => skip cache
            ngx.exec("@disk_cache")
            return
        end

	-- Allowed fields list
        local allowed_keys = { page = true, valid = true }
        local sorted_keys = {}

        for k, v in pairs(data) do
            if not allowed_keys[k] then
                ngx.var.skip_cache = 1 -- If we found filed not from allowed_keys => skip cache completely
                ngx.exec("@disk_cache")
                return
            end
            table.insert(sorted_keys, k)
        end

	-- Format a stable key (sort the fields so that the key does not depend on the order in JSON)
        table.sort(sorted_keys)
        local key_parts = {}
        for _, k in ipairs(sorted_keys) do
            table.insert(key_parts, k .. "=" .. tostring(data[k]))
        end

        ngx.var.my_cache_key = table.concat(key_parts, ":") -- format the final cache key for serving cache
        ngx.exec("@disk_cache")
    }
}

# Internal location, where the cache works
location @disk_cache {
    internal;

    # Set the proper config options for backend
    include fastcgi_params;
    set $my_file "index.php";
    if ($request_uri ~* ^/cache_only_allowed_fields_json/([^?]+)) {
        set $my_file $1;
    }
    fastcgi_param SCRIPT_FILENAME $document_root/$my_file;
    fastcgi_pass php:9000;

    # Use our generated Lua key
    fastcgi_cache MY_CACHE;

    # FastCGI Key and log_by_lua_block block for /purge_cache_fast
    set $full_key "$scheme$request_method$host$request_uri|$my_cache_key";
    fastcgi_cache_key $full_key;

    # Block for /purge_cache_fast (purge logic)
    log_by_lua_block {
        if ngx.var.skip_cache == "0" and ngx.var.my_cache_key ~= "" then
            local cache_index = ngx.shared.cache_index

            -- Calculate cache like Nginx (levels=2:2)
            local hash = ngx.md5(ngx.var.full_key)
            local path = "/var/cache/nginx/" .. string.sub(hash, -2) .. "/" .. string.sub(hash, -4, -3) .. "/" .. hash

	    -- Update cache LUA table (works with HIT and MISS)
            local existing = cache_index:get(ngx.var.uri) or ""
            if not string.find(existing, path, 1, true) then
                cache_index:set(ngx.var.uri, (existing == "" and path or existing .. "," .. path))
            end
        end
    }

    # Cache skip conditions
    fastcgi_cache_bypass $skip_cache;
    fastcgi_no_cache $skip_cache;

    # Get nginx cache TTL.
    # WARNING: May generate additional disk I/O at high load
    header_filter_by_lua_block {
        if ngx.var.upstream_cache_status == "HIT" then
            local key = ngx.var.full_key
            local hash = ngx.md5(key)
            local path = "/var/cache/nginx/" .. string.sub(hash, -2) .. "/" .. string.sub(hash, -4, -3) .. "/" .. hash

	    local f = io.open(path, "rb")
            if f then
                -- Get m_time from Nginx cache file headers
                f:seek("set", 8)
                local bytes = f:read(8)
                f:close()

                if bytes and #bytes == 8 then
                    -- Convert 8 bytes Little-Endian to Lua number
                    local b1, b2, b3, b4, b5, b6, b7, b8 = string.byte(bytes, 1, 8)
                    local timestamp = b1 + b2*256 + b3*65536 + b4*16777216 -- its enough till 2038

                    local age = timestamp - ngx.time()
                    ngx.header["X-Cache-Expires-In"] = age .. "s"
                    ngx.header["X-Cache-Expires-At"] = os.date("!%Y-%m-%d %H:%M:%S GMT", timestamp)
                    -- ngx.header["X-Debug-Timestamp"] = timestamp
                end
            end
        end
    }

    add_header X-Cache-Status $upstream_cache_status;
    add_header X-Debug-Key $my_cache_key;  # Temp for debug

    fastcgi_cache_methods POST; # Enable POST cache
    fastcgi_cache_valid 200 5m;
}





# slow variant, generates high I/O
location /purge_cache {
    allow 127.0.0.1;  # Set restrictions!
    #allow 172.16.0.0/12; # Docker network
    deny all;

    lua_need_request_body on;

    content_by_lua_block {
        local cjson = require "cjson"
        local body = ngx.var.request_body
        local data = cjson.decode(body)

        if not data or not data.pages or type(data.pages) ~= "table" then
            ngx.status = 400
            ngx.say("Invalid JSON. Expected {'pages': ['/uri1', '/uri2']}")
            return
        end

        local cache_path = "/var/cache/nginx"
        local total_deleted = 0

        for _, uri_pattern in ipairs(data.pages) do
            -- Escaping URIs for security in the shell
            local safe_uri = uri_pattern:gsub("'", "'\\''")

	    -- COMMAND: grep -rl - find files => tee - list for the files counting => xargs rm -f - remove these files
            local cmd = string.format("grep -rl '%s' %s | tee /tmp/purged_list | wc -l && xargs rm -f < /tmp/purged_list", safe_uri, cache_path)

            local handle = io.popen(cmd)
            local result = handle:read("*a")
            handle:close()

            local count = tonumber(result) or 0
            total_deleted = total_deleted + count

	    ngx.log(ngx.ERR, "PURGE: Pattern: " .. uri_pattern .. " | Deleted: " .. count)
        end

        ngx.say("Purge command executed for " .. #data.pages .. " patterns." .. "Deleted " .. total_deleted .. " files")
    }
}




# Fast way to purge URI, but LUA table stores only in RAM, and after restart nginx(not reload) it may not found files even if they will be at the FS
location /purge_cache_lua_table {
    allow 127.0.0.1;
    deny all;

    lua_need_request_body on;

    content_by_lua_block {
        local cjson = require "cjson.safe"
        local cache_index = ngx.shared.cache_index
        local body = ngx.var.request_body

        if not body or body == "" then
            ngx.status = 400
            ngx.say("Error: Empty request body. Expected {'pages': ['/uri1', '/uri2*', '*']}")
            return
        end

	local data = cjson.decode(body)

        if not data or type(data.pages) ~= "table" then
            ngx.status = 400
            ngx.say("Error: Invalid format. Expected {'pages': ['/uri1', '/uri2*', '*']}")
            return
        end

        -- Inner function, called later: Delete cache files with exact URI
        local function purge_uri(uri)
            local deleted = 0
            local paths_str = cache_index:get(uri)
            if paths_str then
                for path in string.gmatch(paths_str, '([^,]+)') do
                    if os.remove(path) then
                        deleted = deleted + 1
                    end
                end
                cache_index:delete(uri)
            end
            return deleted
        end

        local deleted_total = 0
        local all_keys = nil

        for _, pattern in ipairs(data.pages) do
            if string.sub(pattern, -1) == "*" then
                -- wildcard logic (ex.: /path/*)
                local prefix = string.sub(pattern, 1, -2) -- remove asterisk

                if not all_keys then all_keys = cache_index:get_keys(0) end

                for _, uri in ipairs(all_keys) do
                    -- Check if URI start with prefix
                    if string.sub(uri, 1, #prefix) == prefix then
                        deleted_total = deleted_total + purge_uri(uri)
                    end
                end
            else
                -- Counting removed pages
                deleted_total = deleted_total + purge_uri(pattern)
            end
        end

        ngx.say("Success: Purge finished. Deleted files: " .. deleted_total)
    }
}




# Get total number of the cache keys in the LUA table
# WARNING: If you have huge amount of rows, count may cause stuck Nginx process for a short time
location /debug_cache_total {
    allow 127.0.0.1;
    deny all;

    default_type application/json;

    content_by_lua_block {
        local cache_index = ngx.shared.cache_index
        local all_keys = cache_index:get_keys(0)

        local total_files = 0
        local total_uris = #all_keys

        for _, uri in ipairs(all_keys) do
            local paths_str = cache_index:get(uri)
            if paths_str then
                -- Count comma separated paths in the row (every path start with /var/cache/nginx, so, just count of includes)
                local _, count = string.gsub(paths_str, "/var/cache/nginx", "")
                total_files = total_files + count
            end
        end

        local response = {
            total_unique_uris = total_uris,
            total_cache_files = total_files
        }

        local cjson = require "cjson"
        ngx.say(cjson.encode(response))
    }
}




# Get 1000 records from the LUA table
location /debug_cache_list {
    allow 127.0.0.1;
    deny all;

    default_type application/json;

    content_by_lua_block {
        local cjson = require "cjson"
        local cjson_safe = require "cjson.safe"
        local cache_index = ngx.shared.cache_index

        local limited_keys = cache_index:get_keys(1000)

        local index_data = {}
        for _, uri in ipairs(limited_keys) do
            local paths_str = cache_index:get(uri)
            local paths = {}
            if paths_str then
                for path in string.gmatch(paths_str, '([^,]+)') do
                    table.insert(paths, path)
                end
            end
            index_data[uri] = paths
        end

        local response = {
            showing_limit = 1000,
            index = index_data
        }
        cjson.encode_sparse_array(true)
	ngx.say(require("cjson").encode(response))
    }
}





    location /lua_ver {
        default_type 'text/plain';
        content_by_lua_block {
            ngx.say("Lua module is active!")
            ngx.say("Nginx version: " .. ngx.var.nginx_version)
        }
    }

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        fastcgi_pass php:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }

}


