# Cache zone config
#fastcgi_cache_path /var/cache/nginx levels=2:2 keys_zone=MY_CACHE:20m inactive=60m max_size=1g;
#fastcgi_cache_key "$scheme$request_method$host$request_uri|$request_body"; # Add $request_body to the key!

# Vocabulary for LUA index - in the http section
#lua_shared_dict cache_index 20m;


server {
    listen 91;
    server_name localhost;
    root /var/www/html;
    index mobile-api.php;

    allow 127.0.0.1;
    allow 192.168.1.0/24;
    deny all;

    # Entrypont for ALL
    location / {
        recursive_error_pages on;

	# Different TTL for /lang_list can be implemented only on a different location
        if ($uri = "/lang_list") {
            error_page 419 = @logic_ttl30;
            return 419;
        }

	error_page 418 = @logic;
        return 418;
    }

    # Main cache logic
    location @logic {
        internal;
        lua_need_request_body on;

        set $my_cache_key "";
        set $skip_cache 0;
	set $full_key "";

        rewrite_by_lua_block {
            -- List of allowed URIs for caching
            local allowed_uris = {
                ["/"] = true,
                ["/lang_list"] = true,
                ["/about"] = true
            }

            -- If URI isn't allowed - skip all other checks
            if not allowed_uris[ngx.var.uri] then
                ngx.var.skip_cache = 1
	    -- For /lang_list => ignore POST data and cache without it
            elseif ngx.var.uri == "/lang_list" then
                ngx.var.my_cache_key = "static_uri_cache"
	    else
                local body = ngx.req.get_body_data()

                -- If the body is empty (ex.: empty POST) - set the cache key as json_empty
                if not body or body == "" then
                    ngx.var.my_cache_key = "json_empty"
                else
                    local cjson = require "cjson"
                    local status, data = pcall(cjson.decode, body)

                    -- If the JSON is not valid => skip cache
                    if not status or type(data) ~= "table" then
                        ngx.var.skip_cache = 1
                    else
                        -- Allowed fields list
                        local allowed_keys = { page = true, valid = true }
                        local sorted_keys = {}
                        local invalid_found = false

                        for k, v in pairs(data) do
                            if not allowed_keys[k] then
                                invalid_found = true
                                break
                            end
                            table.insert(sorted_keys, k)
                        end

                        if invalid_found then
                            -- Fount not allowed field => skip cache
                            ngx.var.skip_cache = 1
                        else
                            -- Make stable key
                            table.sort(sorted_keys)
                            local key_parts = {}
                            for _, k in ipairs(sorted_keys) do
                                table.insert(key_parts, k .. "=" .. tostring(data[k]))
                            end

                            ngx.var.my_cache_key = table.concat(key_parts, ":")

                            if ngx.var.my_cache_key == "" then
                                ngx.var.my_cache_key = "json_empty"
                            end
                        end
                    end
                end
            end
            ngx.var.full_key = ngx.var.scheme .. ngx.var.request_method .. ngx.var.host .. ngx.var.request_uri .. "|" .. ngx.var.my_cache_key
        }

        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root/mobile-api.php;
        fastcgi_pass php:9000;

        # Use our generated Lua key
        fastcgi_cache MY_CACHE;
        fastcgi_cache_key $full_key;

        # Block for /purge_cache_fast (purge logic)
        log_by_lua_block {
            if ngx.var.skip_cache == "0" and ngx.var.my_cache_key ~= "" then
                local cache_index = ngx.shared.cache_index

		-- Calculate cache like Nginx (levels=2:2)
                local hash = ngx.md5(ngx.var.full_key)
                local path = "/var/cache/nginx/" .. string.sub(hash, -2) .. "/" .. string.sub(hash, -4, -3) .. "/" .. hash

		-- Update cache LUA table (works with HIT and MISS)
                local existing = cache_index:get(ngx.var.uri) or ""
                if not string.find(existing, path, 1, true) then
                    cache_index:set(ngx.var.uri, (existing == "" and path or existing .. "," .. path))
                end
            end
        }

        # Cache skip conditions
        fastcgi_cache_bypass $skip_cache;
        fastcgi_no_cache $skip_cache;

        # Get nginx cache TTL
        header_filter_by_lua_block {
            if ngx.var.upstream_cache_status == "HIT" then
                local key = ngx.var.full_key
                local hash = ngx.md5(key)
                local path = "/var/cache/nginx/" .. string.sub(hash, -2) .. "/" .. string.sub(hash, -4, -3) .. "/" .. hash

                local f = io.open(path, "rb")
                if f then
                    f:seek("set", 8)
                    local bytes = f:read(8)
                    f:close()

                    if bytes and #bytes == 8 then
                        local b1, b2, b3, b4, b5, b6, b7, b8 = string.byte(bytes, 1, 8)
                        local timestamp = b1 + b2*256 + b3*65536 + b4*16777216

                        local age = timestamp - ngx.time()
                        ngx.header["X-Cache-Expires-In"] = age .. "s"
                        ngx.header["X-Cache-Expires-At"] = os.date("!%Y-%m-%d %H:%M:%S GMT", timestamp)
                    end
                end
            end
        }

        add_header X-Cache-Status $upstream_cache_status;
        add_header X-Debug-Key $my_cache_key;  # Temp, for debug

        fastcgi_cache_methods POST; # Enable POST cache
        fastcgi_cache_valid 200 5m;
    }


    # Special location for /lang_list with 30m TTL
    location @logic_ttl30 {
        internal;
        lua_need_request_body on;
        set $my_cache_key "";
        set $skip_cache 0;
        set $full_key "";

        rewrite_by_lua_block {
            if ngx.var.uri == "/lang_list" then
                ngx.var.my_cache_key = "static_uri_cache"
            else
                ngx.var.skip_cache = 1
            end
            ngx.var.full_key = ngx.var.scheme .. ngx.var.request_method .. ngx.var.host .. ngx.var.request_uri .. "|" .. ngx.var.my_cache_key
        }

        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root/mobile-api.php;
        fastcgi_pass php:9000;

        fastcgi_cache MY_CACHE;
        fastcgi_cache_key $full_key;

        log_by_lua_block {
            if ngx.var.skip_cache == "0" and ngx.var.my_cache_key ~= "" then
                local cache_index = ngx.shared.cache_index
                local hash = ngx.md5(ngx.var.full_key)
                local path = "/var/cache/nginx/" .. string.sub(hash, -2) .. "/" .. string.sub(hash, -4, -3) .. "/" .. hash
                local existing = cache_index:get(ngx.var.uri) or ""
                if not string.find(existing, path, 1, true) then
                    cache_index:set(ngx.var.uri, (existing == "" and path or existing .. "," .. path))
                end
            end
        }

        fastcgi_cache_bypass $skip_cache;
        fastcgi_no_cache $skip_cache;

        header_filter_by_lua_block {
            if ngx.var.upstream_cache_status == "HIT" then
                local key = ngx.var.full_key
                local hash = ngx.md5(key)
                local path = "/var/cache/nginx/" .. string.sub(hash, -2) .. "/" .. string.sub(hash, -4, -3) .. "/" .. hash
                local f = io.open(path, "rb")
                if f then
                    f:seek("set", 8)
                    local bytes = f:read(8)
                    f:close()
                    if bytes and #bytes == 8 then
                        local b1, b2, b3, b4, b5, b6, b7, b8 = string.byte(bytes, 1, 8)
                        local timestamp = b1 + b2*256 + b3*65536 + b4*16777216
                        local age = timestamp - ngx.time()
                        ngx.header["X-Cache-Expires-In"] = age .. "s"
                        ngx.header["X-Cache-Expires-At"] = os.date("!%Y-%m-%d %H:%M:%S GMT", timestamp)
                    end
                end
            end
        }

        add_header X-Cache-Status $upstream_cache_status;
        add_header X-Debug-Key $my_cache_key;

        fastcgi_cache_methods POST;
        fastcgi_cache_valid 200 30m;
    }


    # Disable direct access to .php scripts
    location ~ \.php$ {
        return 404;
    }
}


